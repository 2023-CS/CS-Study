# Week-1

<details>
  <summary><h2>캐시</h2></summary>
 
- **캐시 메모리**
    - 속도가 빠른 장치와 느린 장치 간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리
    - 메인 메모리와 CPU 사이에 위치
    - 자주 사용하는 프로그램과 데이터를 저장해두어 속도 향상
    

---

- **캐시의 지역성**
    - 데이터에 대한 접근이 시간적 혹은 공간적으로 가깝게 발생하는 것
    - 적중률을 극대화하여 캐시가 효율적으로 동작하기 위해 사용되는 성질
    
    1. 공간 지역성 : 최근에 사용했던 데이터와 인접한 데이터가 참조될 가능성이 높다는 특성
        
        ⇒ ex) 배열 
        
    2. 시간 지역성 : 최근에 사용했던 데이터가 재참조될 가능성이 높은 특성
        
        ⇒ ex) 반복문 / 스택 
        
    

---

- **캐시 미스**
    - CPU가 참조하려는 데이터가 캐시 메모리에 없을 때 발생

---

- **캐시 서버**
    - 인터넷 서비스 속도를 높이기 위해 사용자와 가까운 곳에 데이터를 임시 저장하여 빠르게 제공해주는 **프록시 서버**
    
    - 특징
        - 리소스 파일들의 임시 저장소
            
            ⇒ 자주 사용되는 이미지, html, css, js 파일 등을 브라우저에 저장해놓고 사용
            
        - 같은 자원을 사용할 때 일일이 불러오지 않고 캐시되어 있는 자원을 사용하여 전송량은 줄이고 속도를 높임
        - CDN 서비스 가능
        
    - 문제점
        - 변경된 파일의 참조 불가
            
            ⇒ 서버에서 캐시 만료기간 설정으로 해결가능
            

---

- **프록시 서버**
    - 클라이언트가 자신을 거쳐 다른 네트워크에 접속할 수 있도록 중간에서 대리해주는 서버
    - 클라이언트 → 프록시 → 서버 → 프록시 → 클라이언트
    
    - 사용 목적
        - 캐싱
            - 요청 내용 저장
            - 저장된 내용에 대한 재요청시 서버에 따로 접속하지 않고 저장된 내용 전달
                
                ⇒ 전송시간 절약, 외부 트래픽을 줄임으로써 네트워크 병목현상 방지
                

---

- **CDN**
    - Content Delivery Network
    - 지리, 물리적으로 떨어져 있는 사용자에게 빠르고 안전하게 컨텐츠를 전송하는 기술
    - 서버와 사용자 사이의 물리적인 거리를 줄여 컨텐츠 로딩 소요 시간을 최소화
    - 각 지역에 캐시 서버를 분산 배치해 근접한 사용자 요청에 원본 서버가 아닌 캐시 서버가 컨텐츠 전달
    
    - 장점
        - 웹사이트 로딩 속도 개선
        - 컨텐츠 제공의 안정성
        - 비용 절감
    
    - 작동원리
        1. 최초 요청 : 서버로부터 컨텐츠를 가져와 고객에게 전송하며 CDN 캐싱 장비에 저장
        2. 해당 컨텐츠 만료 시점까지 같은 요청은 CDN 캐싱 장비 컨텐츠 전송
        3. 캐시 미스시 CDN 플랫폼 내 다른 서버에서 찾아서 전송
        4. 컨텐츠 기한 만료시 프록시로 동작하여 서버로부터 컨텐츠를 가져와 고객에게 전송
</details>

<details>
  <summary><h2>메모리 관리 전략</h2></summary>

- 개념
    - 어떤 프로그램이든 프로세스가 되어 프로세서에 적재되기 위해서는 메모리에 적재되어야 실행 가능
    - 성능 향상을 위해서는 여러 개의 프로그램 작동 ⇒ 여러 프로세스 메모리에 적재
    - 따라서 메모리는 중요한 작업 공간이고 한정된 메모리를 다중 프로그래밍 환경에서 이용하기 위해서는 여러 프로세스가 함께 메모리를 사용하므로 효율적인 관리 필요

---

- 메모리 관리 정책
    1. 가져오기 정책(fetch policy) : 필요로 하는 데이터를 언제 메모리로 가져올지 결정
        1. 요구 적재(demand fetch) : 요청 시 메모리에 적재
            
            ex) 요구 페이징
            
        2. 예상 적재(anticipatory fetch) : 미리 예상하여 메모리에 적재
            
            e) 참조 가능성이 높은 페이지 미리 적재
            
    2. 배치 정책(placement policy) : 가져온 데이터를 메모리 어느 위치에 올려 놓을지 결정
        1. 최초 적합(first fit) : 프로그램이나 데이터가 들어갈 수 있는 위치 중 처음 발견한 위치에 배치
            1. 다른 배치 방법에 비해 빠름
            2. 메모리 공간 활용도 떨어짐
        2. 최적 적합(best fit) : 빈 공간을 확인한 이후, 적당한 크기 가운데 가장 작은 공간에 배치
            1. 메모리 단편화가 적게 발생
            2. 탐색 비용 많이 발생
        3. 최악 배치(worst fit) : 빈 공간을 확인한 이후, 가장 큰 공간에 배치
            1. 최적 적합과 같이 탐색 비용 많이 발생
            2. 최적 적합과 달리 남는 공간에 다른 프로세스 및 데이터 배치 가능
            
    3. 교체 정책(replacement policy) : 어떤 데이터를 메모리에서 내보내고 가져올지 결정
        1. swapping : 프로세스를 메모리에서 내보내고, 필요할 때 다시 메모리로 가져오는 기법으로 부족한 메모리 공간으로 인해 사용하는 방법
            1. swap-out : 프로세스를 메모리에서 내보내 스왑영역에 저장
            2. swap-in : 스왑영역에서 다시 메모리 로드
            - 스왑영역 : 내보낸 프로세스가 보관 되는 영영
            - Context Switching으로 인한 오버헤드 발생 가능
            - 속도 느림
            - 메모리 공간 확보에 효율적
        2. page-replacement

---

- 메모리 관리 기법
    1. 메모리 분할
        1. 고정 분할 : 메모리를 같은 크기로 분할
            1. 관리가 수월
            2. 쓸모없는 공간 발생 가능성 (내부 단편화)
            
            ⇒ ex) paging, buddy system
            
        2. 가변 분할 : 메모리를 필요 크기에 따라 분할
            1. 필요로 하는 크기만큼의 공간만 할당
            2. 관리의 어려움
            3. 외부 단편화 발생 가능성
            
            ⇒ ex) segmentation
            
    2. 메모리 할당
        1. 연속 메모리 할당(contiguous memory allocation) : 연속된 메모리 공간에 할당하는 방법
            
            ⇒ ex) 배열
            
        2. 비연속 메모리 할당(noncontiguouse memory allocation) : 여러 조각으로 나누어, 비연속적인 메모리 공간에 할당하는 방법
            
            ⇒ ex) 동적 메모리 할당(dynamic memory allocation)
            
    3. 가상 메모리
        - 실제 메모리 크기와 상관 없이 메모리를 이용할 수 있도록 가상의 메모리 주소를 사용하는 방법
            - 실제 메모리 크기보다 더 큰 공간 사용가능
            - 가상의 주소 공간을 사용하여 논리적인 연속성 제공
            
            ⇒ ex) 페이징, 세그멘테이션
            
---

💡 **메모리란?**
- 메인 메모리, **RAM**을 뜻함
- 프로그램 실행 시 필요한 주소, 정보들을 저장하고 가져다 쓸 수 있게 만드는 공간
- 즉, 작업을 위해 사용되는 공간

<br>

💡 **내부 단편화란?**
- 프로세스가 사용하는 메모리 공간에 포함된 남는 부분
ex) 메모리 분할 공간 100B , Process A 95B ⇒ 5Byte 남음
  
<br>
  
💡 **외부 단편화란?**
- 메모리 공간 중 사용하지 못하게 되는 일부분
- 물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을때 발생

</details>

<details>
  <summary><h2>가상 메모리</h2></summary>

- ******************************기본 아이디어******************************
    - 프로세스는 가상 주소를 사용하고, 실제 데이터를 읽고 쓸 때만 물리 주소로 변환
    - 가상 주소 : 프로세스가 참조하는 주소
    - 물리 주소 : 실제 메모리 주소

---

- **MMU(Memory Management Unit)**
    - CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치

---

- **장점**
    1. 사용자가 기억장소를 일일히 할당하는 불편을 없애준다.
    2. 프로세스의 크기가 실제 메모리의 용량을 초과해도 실행될 수가 있다.
    3. 설사 물리적 메모리의 용량이 충분히 크다하더라도 다중 프로그래밍이 가능하다.
  
</details>

<details>
  <summary><h2>가상 메모리를 이용한 메모리 관리 전략</h2></summary>
  
1. **페이징**
2. **세그멘테이션**
</details>
  
  
<details>
  <summary><h2>동기 / 비동기</h2></summary>
  
- **데이터를 처리하는 방식**
- **동기(synchronous : 동시에 일어나는)**
    - 요청을 하면 (바로) 응답을 받는다는 의미
    - 요청과 그 결과가 동시에 일어난다는 약속
    - 바로 요청을 하면 시간이 얼마가 걸리던지 요청한 자리에서 결과가 주어져야 함
    
    ---
    
    - 장점 : 설계 간단, 직관적
    - 단점 : 결과가 주어질 때까지 무한 대기
    
    ex) Java Scanner
    
- **비동기(Asynchronous : 동시에 일어나지 않는)**
    - 동시에 일어나지 않는다를 의미
    - 요청과 결과가 동시에 일어나지 않을거라는 약속
    - 요청과 응답이 다른 시간대 존재하기 때문에, 요청 내용에 대해 지금 바로 혹은 당장 응답받지 않아도 됨
    
    ---
    
    - 장점 : 결과가 주어지는 동안 다른 작업을 함으로써 자원의 효율적 사용 가능
    - 단점 : 복잡
    
    ex) jQuery Ajax
    
</details>

<details>
  <summary><h2>시스템 콜</h2></summary>

- ******************************************************************************************************************************************OS가 제공하는 서비스를 부르기 위한 인터페이스******************************************************************************************************************************************

- **개요**
    - 일반적인 프로그램들은 유저 모드에서 실행되므로 커널 모드에 대한 직접적인 접근 불가
    - 하지만 커널에 접근할 수 없으면 유저 모드의 프로세스들이 파일을 쓰거나 불러오는 작업 불가
    - 따라서 커널에 요청하여 커널 모드에서 처리하고 그 결과를 사용자 모드의 프로그램에게 전달
    - 사용자 프로세스는 운영체제가 제공하는 여러 서비스들에 직접적인 접근이 아닌 시스템 콜 호출을 통해 서비스를 제공받을 수 있음

---

- ******종류******
    <details>
      <summary><h5>프로세스 제어 (Process Control)</h5></summary>
      
        - 끝내기(exit), 중지 (abort)
        - 적재(load), 실행(execute)
        - 프로세스 생성(create process) - fork
        - 프로세스 속성 획득과 속성 설정
        - 시간 대기 (wait time)
        - 사건 대기 (wait event)
        - 사건을 알림 (signal event)
        - 메모리 할당 및 해제
      
    </details>
        
    <details>
      <summary><h5>파일 조작 (File Manipulation)</h5></summary>
      
        - 파일 생성 / 삭제 (create, delete)
        - 열기 / 닫기 / 읽기 / 쓰기 (open, close, read, wirte)
        - 위치 변경 (reposition)
        - 파일 속성 획득 및 설정 (get file attribute, set file attribute)
        
    </details>
  
    <details>
      <summary><h5>장치 관리 (Device Manipulation)</h5></summary>
      
        - 하드웨어의 제어와 상태 정보를 얻음 (ioctl)
        - 장치를 요구(request device), 장치를 방출 (relese device)
        - 읽기 (read), 쓰기(write), 위치 변경
        - 장치 속성 획득 및 설정
        - 장치의 논리적 부착 및 분리
        
    </details>
      
    <details>
      <summary><h5>정보 유지 (Information Maintenance)</h5></summary>
      
        - getpid(), alarm(), sleep()
        - 시간과 날짜의 설정과 획득 (time)
        - 시스템 데이터의 설정과 획득 (date)
        - 프로세스 파일, 장치 속성의 획득 및 설정
        
    </details>
  
    <details>
      <summary><h5>통신 (Communication)</h5></summary>
      
        - pipe(), shm_open(), mmap()
        - 통신 연결의 생성, 제거
        - 메시지의 송신, 수신
        - 상태 정보 전달
        - 원격 장치의 부착 및 분리
        
    </details>
      
    <details>
      <summary><h5>보호 (Protection)</h5></summary>
      
        - chmod()
        - umask()
        - chown()
        
    </details>

---

- **수행 과정**
    1. 프로세스가 System Call 호출
    2. Trap이 발생하여 Kernel Mode 진입 → 이때 현재 상태 저장
    3. 요청받은 System Call 수행
    4. User Mode로 return

---

- CPU - User Mode / Kernel Mode ⇒ 시스템 보호를 위해
  
---
  
💡 **User** **Mode란?**
- 접근할 수 있는 메모리의 영역이 유저에게 제한되어있어, 시스템 공간에 제한적으로밖에 접근할 수 없는 실행모드
  
<br>
  
💡 **Kernel Mode란?**
- 모든 시스템 메모리와 모든 CPU Instruction에 접근이 가능한 프로세서의 실행모드
- 인터럽트와 시스템 콜로 모드 진입 가능
  
<br>
  
💡 **Privileged Instruction이란?**
- 프로세스의 실행, 종료나 I/O 작업 등의 사용자가 함부로 사용하면 문제가 될 만한 명령들
  
    
</details>

<details>
  <summary><h2>트랩</h2></summary>
  
- Register와 스택 포인터가 저장되고, Context Switching이 일어나고, 실행이 재개될 수 있다는 면에서 인터럽트와 굉장히 흡사하다. 그래서 이를 CPU 내부 인터럽트라고도 한다.
- User Mode -> Kernel Mode 전환해 준다.
- System Call은 주변 장치, 메모리 관리, 등의 커널 모드에서만 조작 가능한 코드를 실행하기 위해 Trap을 통해 구현됨.
      
</details>

<details>
  <summary><h2>인터럽트</h2></summary>
  
- **프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것**
- **발생시기를 예측하기 힘든 경우에 컨트롤러가 가장 빠르게 대응할 수 있는 방법**

- **종류**
    1. 내부 인터럽트 = Trap
        1. 실행할 수 없는 명령어 : 정의되어 있지 않은 명령어
        2. 명령어 실행 오류 : 나누기 0을 하는 경우
        3. 오버 플로우
        
    2. 외부 인터럽트
        1. 타이머 인터럽트 : 타이머가 일정한 시간 간격으로 CPU에게 인터럽트 요청
        2. 입출력 인터럽트 : 속도가 느린 입출력장치가 입출력이 완료되었음을 알리기 위해 요청
        3. 전원 이상
    
    ---
    
    1. 하드웨어 인터럽트
        - 하드웨어가 발생시키는 인터럽트
        - System bus를 통해 CPU에 신호를 보냄으로써 인터럽트를 발생
        
    2. 소프트웨어 인터럽트
        - 소프트웨어가 발생시키는 인터럽트
        - 명령의 요청에 의해 발생한 것
            
            ex) system call
            
---

- **처리 과정**
    1. 인터럽트 발생
    2. 현재 수행 중인 프로그램을 멈추고, 상태 레지스터와 PC 등을 스택에 잠시 저장한 뒤에 인터럽트 서비스 루틴으로 간다.
        
        ⇒ 잠시 저장하는 이유는, 인터럽트 서비스 루틴이 끝난 뒤 다시 원래 작업으로 돌아와야 하기 때문
        
    3. 인터럽트 서비스 수행
    4. 원래 작업으로 복귀

- **이유**
    1. 입출력 연산이 CPU 명령 수행속도보다 현저히 느리기 때문
        - 입출력 연산이 수행되는 동안 CPU는 다른 작업 수행
    
    1. 인터럽트 기능이 없으면 컨트롤러는 특정 시기마다 계속 체크를 해야함 = Polling
        - 수행 기능 저하
        - But 입력이 잦은 경우 Polling 유리 → 마우스
  
</details>

<details>
  <summary><h2>i/o + 파일 시스템</h2></summary>
  
- 컴퓨터에서 파일이나 자료를 쉽게 찾을 수 있도록, 유지, 관리하는 방법
- 파일을 빠르게 읽기, 쓰기, 삭제 등 기본적인 기능을 원활히 수행하기 위한 목적

---

- **특징**
    - 계층적 디렉토리 구조
    - 디스크 파티션 별로 하나씩 둘 수 있음
    - 파일 및 파일의 메타데이터, 디렉터리 정보 등을 관리

---

- **구조**
    
    - 메타 영역 + 데이터 영역
    - 메타 영역 : 데이터 영역에 기록된 파일의 이름, 위치, 크기, 시간정보, 삭제유무 등 파일의 정보가 저장되는 영역
    - 데이터 영역 : 파일의 데이터가 저장되는 영역
    - 직접 파일의 데이터가 필요한 경우가 아니라면 메타영역에 접근해 파일의 정보를 확인할 수 있음

---

- **역할**
    - 파일관리 : 파일 저장, 참조, 공유
    - 보조 저장소 관리 : 저장 공간 할당
    - 파일 무결성 메커니즘 : 파일이 의도한 정보만 포함하고 있음을 의미
    - 접근 방법 : 저장된 데이터에 접근할 수 있는 방법 제공

---

- **목적**
    - HDD와 메인 메모리 속도차 줄이기
    - 파일 관리 용이
    - HDD의 막대한 용량을 효율적으로 이용

---

- ******종류******
    - Windows : FAT(FAT12/16/32,exFAT), NTFS
    - Linux : ext(ext2/3/4)
    - Mac OS : HFS, HFS+
    - Google : GFS

---

- **파일 접근 방법**
    1. 순차 접근 (****sequential**** Access****)****
        1. 가장 단순한 방법
        2. 파일의 정보가 레코드 순서대로 처리
        3. 뒤로 돌아가기 위해선 되감기 필요
        
    2. 직접 접근 (**Random** Access)
        1. 파일의 레코드를 임의의 순서로 접근
        2. 대규모 정보를 즉각적으로 접근하는 데 유용하여 데이터베이스에 이용
        
    3. 색인 접근 (**Index** Access)
        1. 직접 접근 파일에 기반을 두고 색인을 구축
        2. 크기가 큰 파일을 입출력 탐색할 수 있게 도와줌
 
</details> 
